package org.kson.jsonsuite

import org.eclipse.jgit.api.Git
import java.io.File
import java.nio.file.Path

/**
 * [JsonTestSuiteGenerator] generates a class file of tests based on the tests defined in the [JSONTestSuite](https://github.com/nst/JSONTestSuite)
 * project.  By generating the tests into pure Kotlin test methods, we not only have the ergonomics of having
 * an actual test method per JSON Suite test, we also get the benefit of being able to run them across all platforms
 * without wrangling cross-platform file reads
 *
 * See [JsonTestSuiteEditList] for info on the adjustments we make to the JSONTestSuite to suit Kson's needs as a
 * superset of JSON
 *
 * @param jsonTestSuiteSHA The SHA version of the tests to generate from
 * @param projectRoot The absolute path on disk to the root of the project to generate JSONTestSuite tests into
 * @param sourceRoot The source root of the project to place the generated test in, relative to [projectRoot]
 * @param classPackage The package ("org.kson.parser.json") for instance.  NOTES: the caller is responsible for setting
 *                      this correctly
 */
class JsonTestSuiteGenerator(
    val jsonTestSuiteSHA: String,
    private val projectRoot: Path,
    private val sourceRoot: Path,
    private val classPackage: String
) {
    private val buildSrcPath: Path = projectRoot.resolve("buildSrc")

    val testSuiteRootDir: Path = buildSrcPath.resolve("support/jsonsuite/JSONTestSuite")
    val testDefinitionFilesDir: Path = testSuiteRootDir.resolve("test_parsing")
    private val jsonTestSuiteRepoUrl = "https://github.com/nst/JSONTestSuite.git"

    val generatedTestPath: Path =
        projectRoot.resolve(sourceRoot).resolve(classPackage.replace('.', '/')).resolve("JsonSuiteTest.kt")

    fun generate() {
        // sanity check that we're actually running at the project root
        if (!buildSrcPath.toFile().exists()) {
            throw RuntimeException(
                "Kson project buildSrc/ directory not found.  " +
                        "Is parameter `projectRoot` correct?  Current value: $projectRoot"
            )
        }

        ensureCleanGitCheckout(jsonTestSuiteRepoUrl, jsonTestSuiteSHA, testSuiteRootDir)

        //ensure that [testDefinitionFilesDir] contains the desired test source files
        generatedTestPath.parent.toFile().mkdirs()
        val testDataList = JsonTestDataLoader(testDefinitionFilesDir, projectRoot).loadTestData()
        generatedTestPath.toFile()
            .writeText(generateJsonSuiteTestClass(this.javaClass.name, classPackage, testDataList))
    }
}

/**
 * The properties used to generate the expected results enum in [generateJsonSuiteTestClass]
 */
private class ResultEnumData {
    companion object {
        const val className = "JsonParseResult"
        const val acceptEntry = "ACCEPT"
        const val acceptEntryForKson = "ACCEPT_FOR_KSON"
        const val rejectEntry = "REJECT"
        const val unspecifiedEntry = "UNSPECIFIED"
    }
}

private class JsonTestData(
    val rawTestName: String,
    val testSource: String,
    val filePathFromProjectRoot: String,
    val testEditType: JsonTestEditType
) {
    val isSkipped = testEditType == JsonTestEditType.SKIP_NEEDS_INVESTIGATION

    /**
     * Create a legal MPP Kotlin test name out of the raw test name by replacing problematic characters
     */
    val testName = rawTestName.replace("-", "DASH").replace(".", "DOT").replace("+", "PLUS").replace("#", "HASH")

    fun parsingRequirement(): String {
        return when (testEditType) {
            JsonTestEditType.ACCEPT_N_FOR_SUPERSET -> {
                if (!rawTestName.startsWith("n_")) {
                    throw RuntimeException("Invalid use of ${JsonTestEditType.ACCEPT_N_FOR_SUPERSET::class.simpleName}: this edit only applies to overriding `n_`-type rejection tests")
                }
                return ResultEnumData.acceptEntryForKson
            }
            JsonTestEditType.SKIP_NEEDS_INVESTIGATION, JsonTestEditType.NONE -> {
                when {
                    rawTestName.startsWith("i_") -> ResultEnumData.unspecifiedEntry
                    rawTestName.startsWith("y_") -> ResultEnumData.acceptEntry
                    rawTestName.startsWith("n_") -> ResultEnumData.rejectEntry
                    else -> throw RuntimeException("Unexpected test prefix---should only have i/y/n tests")
                }
            }
        }
    }
}

private fun generateJsonSuiteTestClass(
    generatorClassName: String,
    testClassPackage: String,
    tests: List<JsonTestData>
): String {
    return """package $testClassPackage

import org.kson.Kson
import org.kson.parser.LoggedMessage
import kotlin.test.Test
import kotlin.test.assertFalse
import kotlin.test.assertTrue

/**
 * DO NOT MANUALLY EDIT.  This class is GENERATED by `./gradlew generateJsonTestSuite` task 
 * which calls [$generatorClassName]---see that class for more info.
 */
class JsonSuiteTest {

${
        tests.joinToString("\n\n") {
            val theComment = """
        |    /**
        |     * Test generated by [$generatorClassName] based on ${it.rawTestName} in JSONTestSuite (see: ${it.filePathFromProjectRoot})
        |""".trimMargin() +
                    if (it.isSkipped) {
                        "     *\n" +
                                "     * To uncomment and include this test in the running suite, remove it from\n" +
                                "     * [${JsonTestSuiteEditList::class.qualifiedName}] and regenerate this file\n"
                    } else {
                        ""
                    } +
                    """
        |     */
        |""".trimMargin()

            val theTest = """
        |    @Test
        |""".trimMargin() +
                    "    fun ${it.testName}() {\n" +
                    "        assertParseResult(\n" + "            " +
                    "${ResultEnumData.className}.${it.parsingRequirement()},\n" +
                    "            \"\"\"" + it.testSource + "\"\"\"\n" +
                    "        )\n" +
                    "    }"

            theComment + if (it.isSkipped) {
                // comment out our skipped tests
                theTest.split('\n').joinToString("\n//", "//")
            } else {
                theTest
            }
        }
    }
}

private enum class ${ResultEnumData.className} {
    /**
     * Parser must accept the given source as valid JSON
     */
    ${ResultEnumData.acceptEntry},
    
    /**
     * Parser must accept this invalid JSON because it is valid KSON (part of KSON being a superset of JSON)
     */
     ${ResultEnumData.acceptEntryForKson},

    /**
     * Parser must reject the given source as invalid JSON
     */
    ${ResultEnumData.rejectEntry},

    /**
     * The JSON spec does not define a correct response to the given source.
     * i.e. A spec-compliant JSON parser is free accept or reject the given source
     */
    ${ResultEnumData.unspecifiedEntry}
}

private fun assertParseResult(
    expectedParseResult: JsonParseResult,
    source: String
) {
    val parseResult = Kson.parse(source)

    when (expectedParseResult) {
        ${ResultEnumData.className}.${ResultEnumData.acceptEntry}, ${ResultEnumData.className}.${ResultEnumData.acceptEntryForKson} -> assertFalse(
            parseResult.hasErrors(),
            "Should have accepted test source, but rejected as invalid.  Errors produced:\n\n" + LoggedMessage.print(parseResult.messages)
        )
        ${ResultEnumData.className}.${ResultEnumData.rejectEntry} -> assertTrue(
            parseResult.hasErrors(),
            "Should have rejected test source, but accepted as valid Kson.  Do we a new entry in ${JsonTestSuiteEditList::class.simpleName}?"
        )
        ${ResultEnumData.className}.${ResultEnumData.unspecifiedEntry} -> {
            // no-op: doesn't matter if we accept or reject as long as we didn't blow up
        }
    }
}

"""
}

/**
 * This class manages loading and transforming the [JSONTestSuite](https://github.com/nst/JSONTestSuite)
 * tests to facilitate writing them as native, platform-independent, Kotlin tests in [JsonTestSuiteGenerator]
 *
 * Property [jsonTestSuiteEditList] contains the list of tests we currently skip (todo: remove or document all skips)
 *
 * @param testDefinitionFilesDir the [Path] on disk to the [JSONTestSuite](https://github.com/nst/JSONTestSuite) test files
 * @param projectRoot the [Path] on disk of the project containing [testDefinitionFilesDir] - used to write out
 *                      machine-independent file paths relative to the project root
 */
private class JsonTestDataLoader(private val testDefinitionFilesDir: Path, private val projectRoot: Path) {
    private val testFiles = (testDefinitionFilesDir.toFile().listFiles()
        ?: throw RuntimeException("Should be able to list the files since runCommandLineSetup succeeded"))

    init {
        val testDefinitionFileNames = testFiles.map { it.name }.toSet()

        // ensure all the test names in jsonTestSuiteSkipList are valid
        for (testFileName in JsonTestSuiteEditList.all()) {
            if (!testDefinitionFileNames.contains(testFileName)) {
                throw RuntimeException("Invalid JSONTestSuite test file name \"$testFileName\".\n" +
                        "File not found amongst test files in ${testFiles.first().parentFile}:\n" +
                        testFiles.joinToString(",\n") { it.name })
            }
        }
    }

    fun loadTestData(): List<JsonTestData> {
        return testFiles.map {
            JsonTestData(
                it.nameWithoutExtension,
                // explicitly note UTF-8 here since the JSON spec specifies that as the proper json encoding
                it.readText(Charsets.UTF_8),
                it.absolutePath.replace("$projectRoot/", ""),
                JsonTestSuiteEditList.get(it.name)
            )
        }.sortedBy { it.rawTestName }
    }
}

class DirtyRepoException(msg: String) : RuntimeException(msg)

/**
 * Ensures there is a checkout of [repoUrl] in [destinationDir] at SHA [checkoutSHA]
 * Note: will clone if does not exist, will error if not clean
 */
fun ensureCleanGitCheckout(repoUrl: String, checkoutSHA: String, destinationDir: Path) {
    val checkoutDir = destinationDir.toFile()

    if (!checkoutDir.exists()) {
        cloneRepository(repoUrl, checkoutDir)
    }

    val git = Git.init().setDirectory(checkoutDir).call()
    if(!git.status().call().isClean) {
        // throw if we're not clean... don't want to build because the source files might be incorrect,
        // but also don't want to immediately blow it away since someone may have made changes on purpose
        // for reasons we're not guessing, and quietly nuking those changes as a side-effect of the build
        // could do them a real disservice
        throw DirtyRepoException(
            "ERROR: Dirty git status in $destinationDir.  Please ensure the git status is clean " +
                    "or delete the directory and re-run this script")
    }

    checkoutCommit(checkoutDir, checkoutSHA)
}

/**
 * Clone the given [uri] into [dir]
 *
 * @param uri will be passed to [org.eclipse.jgit.api.CloneCommand.setURI] to be parsed as a [org.eclipse.jgit.transport.URIish])
 * @param dir the directory to clone the repo at [uri] into
 */
private fun cloneRepository(uri: String, dir: File) {
    Git.cloneRepository()
        .setURI(uri)
        .setDirectory(dir)
        .call()
}

/**
 * Checks out the given [commit] of the repo found in [dir]
 *
 * @param dir a directory containing a git repo
 * @param commit the commit of the repo in [dir] to be checked out
 */
private fun checkoutCommit(dir: File, commit: String) {
    val git = Git.open(dir)
    git.checkout().setName(commit).call()
}