#!/usr/bin/env node

import {readFileSync, writeFileSync} from 'fs';
import {join, dirname} from 'path';
import {fileURLToPath} from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

interface LanguageConfig {
    id: string;
    aliases?: string[];
    scopeName: string;
    contentName: string;
}

/**
 * To add a new language, add it to this array.
 * The generator will automatically create the TextMate pattern
 */
const languages: LanguageConfig[] = [
    {
        id: 'typescript',
        aliases: ['ts'],
        scopeName: 'source.ts',
        contentName: 'meta.embedded.typescript'
    },
    {
        id: 'jinja',
        aliases: ['jinja'],
        scopeName: 'source.jinja',
        contentName: 'meta.embedded.jinja'
    },
    {
        id: 'javascript',
        aliases: ['js'],
        scopeName: 'source.js',
        contentName: 'meta.embedded.javascript'
    },
    {
        id: 'sql',
        scopeName: 'source.sql',
        contentName: 'meta.embedded.sql'
    },
    {
        id: 'python',
        aliases: ['py'],
        scopeName: 'source.python',
        contentName: 'meta.embedded.python'
    },
    {
        id: 'json',
        scopeName: 'source.json',
        contentName: 'meta.embedded.json'
    },
    {
        id: 'html',
        scopeName: 'text.html.basic',
        contentName: 'meta.embedded.html'
    },
    {
        id: 'css',
        scopeName: 'source.css',
        contentName: 'meta.embedded.css'
    },
    {
        id: 'java',
        scopeName: 'source.java',
        contentName: 'meta.embedded.java'
    },
    {
        id: 'cpp',
        aliases: ['c++', 'cxx'],
        scopeName: 'source.cpp',
        contentName: 'meta.embedded.cpp'
    },
    {
        id: 'csharp',
        aliases: ['cs', 'c#'],
        scopeName: 'source.cs',
        contentName: 'meta.embedded.csharp'
    },
    {
        id: 'go',
        scopeName: 'source.go',
        contentName: 'meta.embedded.go'
    },
    {
        id: 'rust',
        aliases: ['rs'],
        scopeName: 'source.rust',
        contentName: 'meta.embedded.rust'
    },
    {
        id: 'ruby',
        aliases: ['rb'],
        scopeName: 'source.ruby',
        contentName: 'meta.embedded.ruby'
    },
    {
        id: 'yaml',
        aliases: ['yml'],
        scopeName: 'source.yaml',
        contentName: 'meta.embedded.yaml'
    },
    {
        id: 'xml',
        scopeName: 'text.xml',
        contentName: 'meta.embedded.xml'
    },
    {
        id: 'markdown',
        aliases: ['md'],
        scopeName: 'text.html.markdown',
        contentName: 'meta.embedded.markdown'
    },
    {
        id: 'shell',
        aliases: ['sh', 'bash', 'zsh'],
        scopeName: 'source.shell',
        contentName: 'meta.embedded.shell'
    }
];

/**
 * Generate the textmate grammar pattern for injecting a language in an embed block through the embed tag.
 *
 * @param lang - Optional language configuration. If not provided, generates a generic pattern.
 */
function generateEmbedPattern(lang?: LanguageConfig) {
    const isGeneric = !lang;

    // Build the language pattern
    const langPattern = isGeneric
        ? '(.+)?'
        : lang.aliases
            ? `(${lang.id}|${lang.aliases.join('|')})`
            : `(${lang.id})`;

    // Build the name
    const name = isGeneric
        ? 'meta.embedded.block.generic.kson'
        : `meta.embedded.block.${lang.id}.kson`;

    // Build the content name
    const contentName = isGeneric
        ? 'string.unquoted.embedded.kson'
        : lang.contentName;

    // Build the patterns array
    const patterns = isGeneric
        ? []
        : [{include: lang.scopeName}];

    return {
        __comment: `IMPORTANT: Generated by ./scripts/generate-tm-enmbed-block.ts. Edit that file and re-run to update the TextMate grammar.`,
        name,
        begin: `(%|\\$)${langPattern}(:|.|\\s)*?$`,
        beginCaptures: {
            "0": {
                name: "punctuation.section.embedded.begin.kson"
            },
            "1": {
                name: "punctuation.definition.embedded.kson"
            },
            "2": {
                name: "entity.name.tag.embedded.kson"
            }
        },
        end: "^\\s*(\\1\\1)",
        endCaptures: {
            "1": {
                name: "punctuation.section.embedded.end.kson"
            }
        },
        contentName,
        patterns
    };
}

/**
 * Since generating the injection patterns is pretty wieldy and error-prone we generate and update that part of the
 * TextMate Grammar automatically.
 */
function generateTmEmbedBlock() {
    const tmLanguagePath = join(__dirname, '..', 'extension', 'config', 'kson.tmLanguage.json');
    const tmLanguage = JSON.parse(readFileSync(tmLanguagePath, 'utf-8'));

    // Generate patterns for all configured languages
    const embedPatterns = languages.map(lang => generateEmbedPattern(lang));

    // Add the generic catch-all pattern at the end
    embedPatterns.push(generateEmbedPattern());

    // Update the embed-blocks repository
    tmLanguage.repository['embed-blocks'] = {
        patterns: embedPatterns
    };

    // Write the updated file
    writeFileSync(tmLanguagePath, JSON.stringify(tmLanguage, null, 2));
    console.log(`Generated ${embedPatterns.length} embed patterns in ${tmLanguagePath}`);
}

// Run the generator
generateTmEmbedBlock();