package org.kson

import org.kson.CompileTarget.*
import org.kson.CompileTarget.Kson
import org.kson.ast.AstNode
import org.kson.ast.AstNodeError
import org.kson.ast.KsonRoot
import org.kson.stdlibx.collections.ImmutableList
import org.kson.parser.*
import org.kson.parser.messages.MessageType
import org.kson.tools.IndentType

/**
 * Public interface to the [Kson] compiler
 */
class Kson {
    companion object {
        /**
         * Parse the given Kson [source] to an [AstParseResult]. This is the base parse for all the [CompileTarget]s
         * we support, and may be used as a standalone parse to validate a [Kson] document
         *
         * @param source The Kson source to parse
         * @param coreCompileConfig the [CoreCompileConfig] for this parse
         * @return An [AstParseResult]
         */
        fun parseToAst(source: String, coreCompileConfig: CoreCompileConfig = CoreCompileConfig()): AstParseResult {
            val messageSink = MessageSink()
            val tokens = Lexer(
                source,
                // we tokenize gapFree when we are errorTolerant so that error nodes can reconstruct their whitespace
                gapFree = coreCompileConfig.errorTolerant).tokenize()
            if (tokens[0].tokenType == TokenType.EOF) {
                messageSink.error(tokens[0].lexeme.location, MessageType.BLANK_SOURCE.create())
                return AstParseResult(null, tokens, messageSink)
            }

            val builder = KsonBuilder(tokens, coreCompileConfig.errorTolerant)
            Parser(builder, coreCompileConfig.maxNestingLevel).parse()
            val ast = builder.buildTree(messageSink)

            if (coreCompileConfig.schemaJson == NO_SCHEMA) {
                return AstParseResult(ast, tokens, messageSink)
            } else {
                TODO("Json Schema support for Kson not yet implemented")
            }
        }

        /**
         * Parse the given Kson [source] and compile it to Yaml
         *
         * @param source The Kson source to parse
         * @param compileConfig a [CompileTarget.Yaml] object with this compilation's config
         * @return A [YamlParseResult]
         */
        fun parseToYaml(source: String, compileConfig: Yaml = Yaml()): YamlParseResult {
            return YamlParseResult(parseToAst(source, compileConfig.coreConfig), compileConfig)
        }

        /**
         * Parse the given Kson [source] and compile it to Json
         *
         * @param source The Kson source to parse
         * @param compileConfig a [CompileTarget.Json] object with this compilation's config
         * @return A [JsonParseResult]
         */
        fun parseToJson(source: String, compileConfig: Json = Json()): JsonParseResult {
            return JsonParseResult(parseToAst(source, compileConfig.coreConfig), compileConfig)
        }

        /**
         * Parse the given Kson [source] and re-compile it out to Kson.  Useful for testing and transformations
         * like re-writing Json into Kson (the Json is itself Kson since Kson is a superset of Json, whereas the
         * compiled Kson output is in more canonical Kson syntax)
         *
         * @param source The Kson source to parse
         * @param compileConfig a [CompileTarget.Kson] object with this compilation's config
         * @return A [KsonParseResult]
         */
        fun parseToKson(source: String, compileConfig: Kson = Kson()): KsonParseResult {
            return KsonParseResult(parseToAst(source, compileConfig.coreConfig), compileConfig)
        }

        /**
         * Format the given [Kson] source
         */
        fun format(ksonSource: String, formatterConfig: KsonFormatterConfig = KsonFormatterConfig()): String {
            if (ksonSource.isBlank()) return ""
            return KsonParseResult(
                parseToAst(ksonSource, CoreCompileConfig(errorTolerant = true)),
                Kson(preserveComments = true, formatterConfig)
            ).kson ?: ksonSource
        }
    }
}

/**
 * The type generated by our [Kson] parser
 */
interface ParseResult {
    /**
     * The parsed AST, or null if the source was invalid kson (in which cases [hasErrors] will be true)
     */
    val ast: KsonRoot?

    /**
     * The tokens lexed from the input source, provided for debug purposes
     */
    val lexedTokens: List<Token>

    /**
     * The user-facing messages logged during this parse
     */
    val messages: ImmutableList<LoggedMessage>

    /**
     * True if the input source could not be parsed. [messages] will contain errors in this case.
     */
    fun hasErrors(): Boolean
}

/**
 * Core [ParseResult] produced by the [Kson] parser attempting to create a Kson abstract syntax tree ([ast])
 * from some Kson source
 */
data class AstParseResult(
    override val ast: KsonRoot?,
    override val lexedTokens: List<Token>,
    private val messageSink: MessageSink
) : ParseResult {
    override val messages = messageSink.loggedMessages()

    override fun hasErrors(): Boolean {
        return messageSink.hasErrors()
    }
}

class KsonParseResult(
    private val astParseResult: AstParseResult,
    compileConfig: Kson
) : ParseResult by astParseResult {
    /**
     * The Kson compiled from some Kson source, or null if there were errors trying to parse
     * (consult [astParseResult] for information on any errors)
     */
    val kson: String? = astParseResult.ast?.toSource(
        AstNode.Indent(compileConfig.formatConfig.indentType),
        compileConfig)
}

class YamlParseResult(
    private val astParseResult: AstParseResult,
    compileConfig: Yaml
) : ParseResult by astParseResult {
    /**
     * The Yaml compiled from some Kson source, or null if there were errors trying to parse
     * (consult [astParseResult] for information on any errors)
     */
    val yaml: String? = astParseResult.ast?.toSource(AstNode.Indent(), compileConfig)
}

class JsonParseResult(
    private val astParseResult: AstParseResult,
    compileConfig: Json
) : ParseResult by astParseResult {
    /**
     * The Json compiled from some Kson source, or null if there were errors trying to parse
     * (consult [astParseResult] for information on any errors)
     */
    val json: String? = astParseResult.ast?.toSource(AstNode.Indent(), compileConfig)
}



/**
 * Type to denote a supported Kson compilation target and hold the compilation's configuration
 */
sealed class CompileTarget(val coreConfig: CoreCompileConfig) {
    /**
     * Whether this compilation should preserve comments from the input [Kson] source in the compiled output
     */
    abstract val preserveComments: Boolean

    /**
     * Compile target for serializing a Kson AST out to Kson source
     *
     * @param formatConfig the settings for formatting the compiler Kson output
     * @param coreCompileConfig the [CoreCompileConfig] for this compile
     */
    class Kson(
        override val preserveComments: Boolean = true,
        val formatConfig: KsonFormatterConfig = KsonFormatterConfig(),
        coreCompileConfig: CoreCompileConfig = CoreCompileConfig()
    ) : CompileTarget(coreCompileConfig)

    /**
     * Compile target for Yaml transpilation
     *
     * @param retainEmbedTags If true, embed blocks will be compiled to objects containing both tag and content
     * @param coreCompileConfig the [CoreCompileConfig] for this compile
     */
    class Yaml(
        override val preserveComments: Boolean = true,
        val retainEmbedTags: Boolean = false,
        coreCompileConfig: CoreCompileConfig = CoreCompileConfig()
    ) : CompileTarget(coreCompileConfig)

    /**
     * Compile target for Json transpilation
     *
     * @param retainEmbedTags If true, embed blocks will be compiled to objects containing both tag and content
     * @param coreCompileConfig the [CoreCompileConfig] for this compile
     */
    class Json(
        val retainEmbedTags: Boolean = false,
        coreCompileConfig: CoreCompileConfig = CoreCompileConfig()
    ) : CompileTarget(coreCompileConfig) {
        // Json does not support comments
        override val preserveComments: Boolean = false
    }
}

/**
 * Configuration applicable to all compile targets
 */
data class CoreCompileConfig(
    /**
     * The [JSON Schema](https://json-schema.org/) to enforce in this compilation
     */
    val schemaJson: String = NO_SCHEMA,
    /**
     * Whether to allow an AST to be built with errors (i.e. patched with [AstNodeError] nodes)
     */
    val errorTolerant: Boolean = false,
    /**
     * The deep object/list nesting to allow in the parsed document.  See [DEFAULT_MAX_NESTING_LEVEL] for more details.
     */
    val maxNestingLevel: Int = DEFAULT_MAX_NESTING_LEVEL
)

data class KsonFormatterConfig(val indentType: IndentType = IndentType.Space(2))

/**
 * A Json document specifying just `true` is the "trivial" schema that matches everything,
 * and so is equivalent to not having a schema.  See https://json-schema.org/draft/2020-12/json-schema-core#section-4.3.2
 * for more detail
 */
private const val NO_SCHEMA = "true"
